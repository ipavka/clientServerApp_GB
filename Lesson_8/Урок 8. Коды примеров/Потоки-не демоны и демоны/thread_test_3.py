"""Главный поток и дочерний поток (демон)"""

import threading
import time
from logging import info, basicConfig, INFO

"""
Немного магии. Как хорошо, что есть демонические потоки. 
Мы закрываем программу и больше не думаем,
'висят' ли какие-то потоки. Зачем об этом думать, 
если поток-демон и завершится сразу с закрытием программы
Но ведь может возникнуть ситуация, что мы захотим таки дождаться 
завершения потока. Но при этом мы хотим знать, что
в случае досрочного завершения программы и фоновые потоки завершатся. 
Как быть? Полчается, что мы хотим совместить
возможности и демонов, и не демонов.
"""


def demo_thr_func(name):
    """Логика функции для дочернего потока"""
    info(f'Дочерний поток {name} стартует')
    time.sleep(2)
    info(f'Дочерний поток {name} завершается')


if __name__ == "__main__":
    basicConfig(
        format="%(asctime)s: %(message)s",
        level=INFO,
        datefmt="%H:%M:%S")
    info("Приложение: до создания дочернего потока")
    THR_OBJ = threading.Thread(target=demo_thr_func, args=(1,), daemon=True)
    info("Приложение: до старта дочернего потока")
    THR_OBJ.start()
    THR_OBJ.join()
    info("Приложение: завершилось после того, как завершился дочерний поток")

"""
Чтобы указать одному потоку дождаться завершения другого потока, вам нужно вызывать .join().
В данном примере основной поток остановится и будет ждать завершения дочернего потока.
"""

"""
Т.е. мы используем функцию join() только с потоком-демоном? Не обязательно.
С каким потом она будет работать, с демоническим потоком или с обычным? 
Оказывается, это не имеет значения. Если вы вызвали .join(), 
этот оператор будет ждать, пока не завершится любой вид потока.
"""
